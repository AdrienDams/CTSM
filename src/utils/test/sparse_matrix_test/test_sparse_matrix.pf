module test_sparse_matrix

  ! Tests of Sparse Matrix Multiply module

  use pfunit_mod
  use SPMMod
  use shr_kind_mod , only : r8 => shr_kind_r8
  use unittestUtils, only : endrun_msg

  implicit none

  @TestCase
  type, extends(TestCase) :: TestSparseMatrix
     type(sparse_matrix_type) :: SM_identity
     type(diag_matrix_type)   :: DM_identity
     type(vector_type)        :: V_identity
     integer                  :: num_unit
     integer, allocatable     :: filter_u(:)
   contains
     procedure :: setUp
     procedure :: tearDown
  end type TestSparseMatrix

  integer, parameter :: ndims = 10
  integer, parameter :: begu = 1, endu = 2

  integer, parameter :: NonZero = ndims + ndims - 1 + ndims - 2
  type :: arb_band_sparse_matrix_setup
     real(r8) :: M(NonZero)
     integer :: Iindex(NonZero)
     integer :: Jindex(NonZero)
  contains
     procedure :: createArbBandMatrix
     procedure :: createArbBandMatrix2
  end type arb_band_sparse_matrix_setup
  integer, parameter :: NonZeroTriNoDiag = ndims*ndims*0.5 - ndims*0.5
  type :: tri_nodiag_sparse_matrix_setup
     real(r8) :: M(NonZeroTriNoDiag)
     integer :: Iindex(NonZeroTriNoDiag)
     integer :: Jindex(NonZeroTriNoDiag)
  contains
     procedure :: createArbLoTriMatrix
     procedure :: createArbHiTriMatrix
  end type tri_nodiag_sparse_matrix_setup
contains

  subroutine  createArbBandMatrix( this )
    class(arb_band_sparse_matrix_setup), intent(inout) :: this

    integer :: i, band, nz, band_size
    ! Set up an arbitrary upper tri-diagonal matrix (3 bands)
    ! This isn't right...
    nz = 0
    band_size = ndims
    do band = 1, 3
      do i = 1, band_size
        nz = nz + 1
        this%M(nz) = real(i*100 + band,r8)
        this%Iindex(nz) = i + band - 1
        this%Jindex(nz) = i
      end do
      band_size = band_size - 1
    end do
    @assertEqual(nz,NonZero)
  end subroutine createArbBandMatrix

  subroutine  createArbBandMatrix2( this )
    class(arb_band_sparse_matrix_setup), intent(inout) :: this

    integer :: i, j, band, nz
    ! Set up an arbitrary upper tri-diagonal matrix (3 bands)
    nz = 0
    do j = 1, ndims
      do i = j, min(ndims,j+2)
        nz = nz + 1
        this%M(nz) = real(i*100 + j,r8)
        this%Iindex(nz) = i
        this%Jindex(nz) = j
      end do
    end do
    @assertEqual(nz,NonZero)
  end subroutine createArbBandMatrix2

  subroutine  createArbLoTriMatrix( this )
    class(tri_nodiag_sparse_matrix_setup), intent(inout) :: this

    integer :: i, nz
    ! Set up an arbitrary lower triagional matrix without the diagonal
    nz = 0
    do j = 2, ndims
      do i = 1, j-1
        nz = nz + 1
        this%M(nz) = real(j*100 + i,r8)
        this%Iindex(nz) = i
        this%Jindex(nz) = j
      end do
    end do
    @assertEqual(nz,NonZeroTriNoDiag)
  end subroutine createArbLoTriMatrix

  subroutine  createArbUpTriMatrix( this )
    class(tri_nodiag_sparse_matrix_setup), intent(inout) :: this

    integer :: i, nz
    ! Set up an arbitrary upper triagional matrix without the diagonal
    nz = 0
    do j = 1, ndims-1
      do i = j+1, ndims
        nz = nz + 1
        this%M(nz) = real(j*1000 + i*10,r8)
        this%Iindex(nz) = i
        this%Jindex(nz) = j
      end do
    end do
    @assertEqual(nz,NonZeroTriNoDiag)
  end subroutine createArbUpTriMatrix

  subroutine setUp(this)
    class(TestSparseMatrix), intent(inout) :: this

    integer :: i
    real(r8) :: Mdiag(begu:endu,ndims)

    this%num_unit = endu - begu + 1
    allocate( this%filter_u(this%num_unit) )
    do i = begu, endu
       this%filter_u(i) = i
    end do
    call this%SM_identity%InitSM( ndims, begu, endu )
    call this%SM_identity%SetValueA_diag( this%num_unit,this%filter_u, 1.0_r8 )
    call this%DM_identity%InitDM( ndims, begu, endu )
    Mdiag = 1.0_r8
    call this%DM_identity%SetValueDM(begu,endu,this%num_unit,this%filter_u,Mdiag)
    call this%V_identity%InitV( ndims, begu, endu )
    call this%V_identity%SetValueV_scaler( this%num_unit,this%filter_u, 1.0_r8 )
  end subroutine setUp

  subroutine tearDown(this)
    class(TestSparseMatrix), intent(inout) :: this

    call this%V_identity%ReleaseV( )
    deallocate( this%filter_u )
  end subroutine tearDown

  @Test
  subroutine SM_Identity_times_ArbDiagMatrix_is_self( this )
    use shr_const_mod, only: SHR_CONST_PI
    class(TestSparseMatrix), intent(inout) :: this

    type(diag_matrix_type) :: Kmatrix
    real(r8) :: Mdiag(ndims)
    integer :: i

    ! Set up an arbitrary diagonal matrix
    call Kmatrix%InitDM( ndims, begu, endu )
    do i = 1, ndims
      Mdiag(i) = real(i,r8)*SHR_CONST_PI
    end do
    call Kmatrix%SetValueDM( begu, endu, this%num_unit,this%filter_u, Mdiag )
    ! Multiply by the identity matrix already stored
    call this%SM_identity%SPMM_AK( this%num_unit,this%filter_u, Kmatrix )
    ! Result (now stored in identity matrix) should now be the same
    @assertEqual( Kmatrix%DM, this%SM_identity%M(:,:this%SM_identity%NE) )

  end subroutine SM_Identity_times_ArbDiagMatrix_is_self

  @Test
  subroutine SM_Identity_times_ArbMatrix_is_self( this )
    use shr_const_mod, only: SHR_CONST_PI
    class(TestSparseMatrix), intent(inout) :: this

    type(diag_matrix_type) :: Kidentity
    type(sparse_matrix_type) :: ArbSMatrix, ArbSMatrix2
    real(r8) :: Mdiag(ndims)
    integer :: i
    type(arb_band_sparse_matrix_setup) :: MatrixSetup

    call MatrixSetup%createArbBandMatrix2( )
    call ArbSMatrix%InitSM( ndims, begu, endu )
    call ArbSMatrix%SetValueSM(begu,endu,this%num_unit,this%filter_u, &
                               MatrixSetup%M,MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)
    call ArbSMatrix2%InitSM( ndims, begu, endu )
    call ArbSMatrix2%SetValueSM(begu,endu,this%num_unit,this%filter_u, &
                               MatrixSetup%M,MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)

    ! Set up a identity diagonal matrix
    call Kidentity%InitDM( ndims, begu, endu )
    do i = 1, ndims
      Mdiag(i) = 1.0_r8
    end do
    call Kidentity%SetValueDM( begu, endu, this%num_unit,this%filter_u, Mdiag )
    ! Multiply diagonal identity by the arbitrary matrix created, result should be self
    call ArbSMatrix%SPMM_AK( this%num_unit,this%filter_u, Kidentity )
    @assertEqual( NonZero, ArbSMatrix%NE )
    @assertEqual( ArbSMatrix%M(:,:NonZero), ArbSMatrix2%M(:,:NonZero) )
    @assertEqual( ArbSMatrix%RI(:NonZero), ArbSMatrix2%RI(:NonZero) )
    @assertEqual( ArbSMatrix%CI(:NonZero), ArbSMatrix2%CI(:NonZero) )

  end subroutine SM_Identity_times_ArbMatrix_is_self

  @Test
  subroutine V_Identity_times_ArbVector_plus_self__is_twice_self( this )
    use shr_const_mod, only: SHR_CONST_PI
    class(TestSparseMatrix), intent(inout) :: this

    type(vector_type) :: vector
    real(r8) :: Mdiag(begu:endu,ndims)
    integer :: i

    call vector%InitV( ndims, begu, endu )
    do i = 1, ndims
       Mdiag(:,i) = real(i*10,r8)
    end do
    call vector%SetValueV( begu, endu, this%num_unit,this%filter_u, Mdiag(begu:endu,:) )
    ! Multiply by the identity matrix already stored
    call vector%SPMM_AX( this%num_unit,this%filter_u, this%SM_identity )
    ! Result (now stored in vector)
    @assertEqual( vector%V, Mdiag*2.0_r8 )
    call vector%ReleaseV()

  end subroutine V_Identity_times_ArbVector_plus_self__is_twice_self

  @Test
  subroutine SM_ArbTriMatrix_plus_self_is_twice_self( this )
    class(TestSparseMatrix), intent(inout) :: this

    type(sparse_matrix_type) :: ArbSMatrix, ArbSMatrix2
    type(arb_band_sparse_matrix_setup) :: MatrixSetup

    call MatrixSetup%createArbBandMatrix2( )
    call ArbSMatrix%InitSM( ndims, begu, endu )
    call ArbSMatrix%SetValueSM(begu,endu,this%num_unit,this%filter_u, &
                               MatrixSetup%M,MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)
    ! Second matrix is identical
    call ArbSMatrix2%InitSM( ndims, begu, endu )
    call ArbSMatrix2%SetValueSM(begu,endu,this%num_unit,this%filter_u, &
                               MatrixSetup%M,MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)

    call ArbSmatrix%SPMP_B_ACC(this%num_unit,this%filter_u,ArbSmatrix2)
    ! Result should now be twice the original
    @assertEqual( ArbSmatrix%M(:,:ArbSmatrix%NE), 2.0_r8*ArbSmatrix2%M(:,:ArbSmatrix2%NE) )

  end subroutine SM_ArbTriMatrix_plus_self_is_twice_self

  @Test
  subroutine SM_ArbTriMatrix_plus_self_is_twice_self_wSPMP_AB( this )
    class(TestSparseMatrix), intent(inout) :: this

    type(sparse_matrix_type) :: ArbSMatrix, ArbSMatrix2
    type(arb_band_sparse_matrix_setup) :: MatrixSetup
    integer :: list_A(NonZero), list_B(NonZero)
    integer :: RI(2*NonZero), CI(2*NonZero) 
    integer :: NonZero_AB
    logical :: list_ready = .false.

    call MatrixSetup%createArbBandMatrix2( )
    call ArbSMatrix%InitSM( ndims, begu, endu )
    call ArbSMatrix%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetup%M, &
                               MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)
    ! Second matrix is identical
    call ArbSMatrix2%InitSM( ndims, begu, endu )
    call ArbSMatrix2%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetup%M, &
                               MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)

    list_ready = .false.
    call this%SM_identity%SPMP_AB(this%num_unit,this%filter_u,ArbSmatrix,ArbSmatrix2,list_ready,list_A,list_B, &
                                  NonZero_AB, RI, CI)
    @assertTrue( list_ready )
    @assertEqual(NonZero_AB, NonZero)
    call this%SM_identity%SPMP_AB(this%num_unit,this%filter_u,ArbSmatrix,ArbSmatrix2,list_ready,list_A,list_B, &
                                  NonZero_AB, RI, CI)
    ! Result should now be twice the original
    @assertEqual( this%SM_identity%M(:,:ArbSmatrix%NE), 2.0_r8*ArbSmatrix2%M(:,:ArbSmatrix2%NE) )

  end subroutine SM_ArbTriMatrix_plus_self_is_twice_self_wSPMP_AB

  @Test
  subroutine SM_ArbTriMatrix_plus_self_twice_is_thrice_self_wSPMP_AB( this )
    class(TestSparseMatrix), intent(inout) :: this

    type(sparse_matrix_type) :: ArbSMatrix, ArbSMatrix2, ArbSMatrix3
    type(arb_band_sparse_matrix_setup) :: MatrixSetup
    integer :: list_A(NonZero), list_B(NonZero), list_C(NonZero)
    integer :: RI(3*NonZero), CI(3*NonZero) 
    integer :: NonZero_ABC
    logical :: list_ready = .false.


    call MatrixSetup%createArbBandMatrix2( )
    call ArbSMatrix%InitSM( ndims, begu, endu )
    call ArbSMatrix%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetup%M, &
                                MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)
    ! Second matrix is identical
    call ArbSMatrix2%InitSM( ndims, begu, endu )
    call ArbSMatrix2%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetup%M, &
                                MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)
    ! Third matrix is identical
    call ArbSMatrix3%InitSM( ndims, begu, endu )
    call ArbSMatrix3%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetup%M, &
                                MatrixSetup%Iindex,MatrixSetup%Jindex,NonZero)

    list_ready = .false.
    call this%SM_identity%SPMP_ABC( this%num_unit,this%filter_u,ArbSMatrix,ArbSMatrix2,ArbSMatrix3, &
                                   list_ready,list_A,list_B,list_C,NonZero_ABC,RI,CI)
    @assertTrue( list_ready )
    call this%SM_identity%SPMP_ABC( this%num_unit,this%filter_u,ArbSMatrix,ArbSMatrix2,ArbSMatrix3, &
                                   list_ready,list_A,list_B,list_C,NonZero_ABC,RI,CI)
    @assertEqual(NonZero_ABC, NonZero)
    ! Result should now be thrice the original
    @assertEqual( this%SM_identity%M(:,:ArbSmatrix%NE), 3.0_r8*ArbSmatrix2%M(:,:ArbSmatrix2%NE) )

  end subroutine SM_ArbTriMatrix_plus_self_twice_is_thrice_self_wSPMP_AB

  @Test
  subroutine SM_lower_plus_upper_plus_diag_equal_filled( this )
    class(TestSparseMatrix), intent(inout) :: this

    type(sparse_matrix_type) :: ArbSMatrixLo, ArbSMatrixHi, ArbSMatrixDiag
    type(tri_nodiag_sparse_matrix_setup) :: MatrixSetupLo, MatrixSetupHi
    integer :: list_A(NonZeroTriNoDiag), list_B(NonZeroTriNoDiag), list_C(ndims)
    integer :: RI(ndims*ndims), CI(ndims*ndims) 
    integer :: one(ndims*ndims)
    integer :: NonZero_ABC
    integer :: i
    logical :: list_ready = .false.


    ! Lower tridiagonal matrix without the diagonal
    call MatrixSetupLo%createArbLoTriMatrix( )
    call ArbSMatrixLo%InitSM( ndims, begu, endu )
    MatrixSetupLo%M = 1.0_r8   ! Set all elements to one
    call ArbSMatrixLo%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetupLo%M, &
                                MatrixSetupLo%Iindex,MatrixSetupLo%Jindex,NonZeroTriNoDiag)
    ! Upper tridiagonal matrix without the diagonal
    call MatrixSetupHi%createArUpTriMatrix( )
    call ArbSMatrixHi%InitSM( ndims, begu, endu )
    MatrixSetupHi%M = 1.0_r8   ! Set all elements to one
    call ArbSMatrixHi%SetValueSM(begu,endu,this%num_unit,this%filter_u,MatrixSetupLo%M, &
                                MatrixSetupLo%Iindex,MatrixSetupLo%Jindex,NonZeroTriNoDiag)
    ! Third matrix used is the diagonal identity matrix
    call ArbSMatrixDiag%InitSM( ndims, begu, endu )
    call ArbSMatrixDiag%SetValueA_diag(this%num_unit,this%filter_u, 1.0_r8 )
    ! Sum them all together
    list_ready = .false.
    call this%SM_identity%SPMP_ABC( this%num_unit,this%filter_u,ArbSMatrixLo,ArbSMatrixHi,ArbSMatrixDiag, &
                                   list_ready,list_A,list_B,list_C,NonZero_ABC,RI,CI)
    @assertTrue( list_ready )
    call this%SM_identity%SPMP_ABC( this%num_unit,this%filter_u,ArbSMatrix,ArbSMatrix2,ArbSMatrix3, &
                                   list_ready,list_A,list_B,list_C,NonZero_ABC,RI,CI)
    @assertEqual(NonZero_ABC, ndims*ndims)
    ! Result should have all elements filled in and equal to one
    one = 1.0_r8
    do i = begu, endu
       @assertEqual( this%SM_identity%M(i,:), one )
    end do

  end subroutine SM_lower_plus_upper_plus_diag_equal_filled

end module test_sparse_matrix
