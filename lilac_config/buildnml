#!/usr/bin/env python3

"""
CTSM namelist creator
"""

import sys
import os
import subprocess
import argparse

from configparser import ConfigParser
from configparser import NoSectionError, NoOptionError

_CONFIG_CACHE_TEMPLATE = """
<?xml version="1.0"?>
<config_definition>
<commandline></commandline>
<entry id="phys" value="{clm_phys}" list="" valid_values="clm4_5,clm5_0">Specifies clm physics</entry>
</config_definition>
"""

# Note the following is needed in env_lilac.xml otherwise the following error appears in
# the call to build_namelist

#err=ERROR : CLM build-namelist::CLMBuildNamelist::logical_to_fortran() :
# Unexpected value in logical_to_fortran:

_ENV_LILAC_TEMPLATE = """
<?xml version="1.0"?>
<file id="env_lilac.xml" version="2.0">
  <group id="run_glc">
    <entry id="GLC_TWO_WAY_COUPLING" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
    </entry>
  </group>
</file>
"""

# This string is used in the out-of-the-box ctsm.cfg file to denote a value that needs to
# be filled in
_PLACEHOLDER = 'FILL_THIS_IN'

# This string is used in the out-of-the-box ctsm.cfg file to denote a value that can be
# filled in, but doesn't absolutely need to be
_UNSET = 'UNSET'

###############################################################################
def parse_command_line(args, description):
###############################################################################

    """Parse the command line, return object holding arguments"""

    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
                                     description=description)

    parser.add_argument("--rundir", type=str, default=os.getcwd(),
                        help="Full path of the run directory")

    parser.add_argument("--existing-res",
                        help="Use the given out-of-the-box resolution (e.g., '4x5').\n"
                        "This argument should NOT be provided for a user-defined resolution.\n"
                        "If this argument is provided, then --existing-mask must also be provided.")

    parser.add_argument("--existing-mask",
                        help="Use the given out-of-the-box mask (e.g., 'gx3v7').\n"
                        "This argument should NOT be provided for a user-defined resolution.\n"
                        "If this argument is provided, then --existing-res must also be provided.")

    arguments = parser.parse_args(args)

    # Perform some error checking on arguments, and set derived values

    if not os.path.isdir(arguments.rundir):
        sys.exit("rundir {} does not exist".format(arguments.rundir))

    if arguments.existing_res and arguments.existing_mask:
        arguments.use_existing_res_and_mask = True
    elif arguments.existing_res and not arguments.existing_mask:
        sys.exit("If --existing-res is given, then --existing-mask must also be given")
    elif arguments.existing_mask and not arguments.existing_res:
        sys.exit("If --existing-mask is given, then --existing-res must also be given")
    else:
        arguments.use_existing_res_and_mask = False

    return arguments

###############################################################################
def get_config_value(config, section, item, file_path, allowed_values=None):
    """Get a given item from a given section of the config object

    Give a helpful error message if we can't find the given section or item

    Note that the file_path argument is only used for the sake of the error message

    If allowed_values is present, it should be a list of strings giving allowed values
    """
    try:
        val = config.get(section, item)
    except NoSectionError:
        sys.exit("ERROR: Config file {} must contain section '{}'".format(file_path, section))
    except NoOptionError:
        sys.exit("ERROR: Config file {} must contain item '{}' in section '{}'".format(
            file_path, item, section))

    if val == _PLACEHOLDER:
        sys.exit("Error: {} needs to be specified in config file {}".format(item, file_path))

    if allowed_values is not None:
        if val not in allowed_values:
            sys.exit("Error: {} is not an allowed value for {} in config file {}\n"
                     "Allowed values: {}".format(val, item, file_path, allowed_values))

    return val

###############################################################################
def determine_bldnml_opts(bgc_mode, crop, vichydro):
###############################################################################
    """Return a string giving bldnml options, given some other inputs"""
    bldnml_opts = ''
    bldnml_opts += ' -bgc {}'.format(bgc_mode)
    if bgc_mode == 'fates':
        # BUG(wjs, 2020-06-12, ESCOMP/CTSM#115) For now, FATES is incompatible with MEGAN
        bldnml_opts += ' -no-megan'

    if crop == 'on':
        if bgc_mode not in ['bgc', 'cn']:
            sys.exit("Error: setting crop to 'on' is only compatible with bgc_mode of 'bgc' or 'cn'")
        bldnml_opts += ' -crop'

    if vichydro == 'on':
        if bgc_mode != 'sp':
            sys.exit("Error: setting vichydro to 'on' is only compatible with bgc_mode of 'sp'")
        bldnml_opts += ' -vichydro'

    return bldnml_opts

###############################################################################
def buildnml(rundir, bldnmldir, use_existing_res_and_mask, existing_res=None, existing_mask=None):
###############################################################################

    """Build the ctsm namelist

    If use_existing_res_and_mask is True, then existing_res and existing_mask should be
    specified; otherwise, they are ignored.
    """

    # pylint: disable=too-many-locals

    file_path = os.path.join(rundir, 'ctsm.cfg')

    # read the config file
    config = ConfigParser()
    config.read(file_path)

    lnd_domain_file = get_config_value(config, 'buildnml_input', 'lnd_domain_file', file_path)
    if use_existing_res_and_mask:
        fsurdat = _UNSET
    else:
        # If we're not using an out-of-the-box grid, then require the user to explicitly
        # specify the surface dataset.
        fsurdat = get_config_value(config, 'buildnml_input', 'fsurdat', file_path)
    finidat = get_config_value(config, 'buildnml_input', 'finidat', file_path)

    ctsm_phys = get_config_value(config, 'buildnml_input', 'ctsm_phys', file_path,
                                 allowed_values=['clm4_5', 'clm5_0'])
    configuration = get_config_value(config, 'buildnml_input', 'configuration', file_path,
                                     allowed_values=['nwp', 'clm'])
    structure = get_config_value(config, 'buildnml_input', 'structure', file_path,
                                 allowed_values=['fast', 'standard'])
    bgc_mode = get_config_value(config, 'buildnml_input', 'bgc_mode', file_path,
                                allowed_values=['sp', 'bgc', 'cn', 'fates'])
    crop = get_config_value(config, 'buildnml_input', 'crop', file_path,
                            allowed_values=['off', 'on'])
    vichydro = get_config_value(config, 'buildnml_input', 'vichydro', file_path,
                                allowed_values=['off', 'on'])

    bldnml_opts = determine_bldnml_opts(bgc_mode=bgc_mode,
                                        crop=crop,
                                        vichydro=vichydro)

    co2_ppmv = get_config_value(config, 'buildnml_input', 'co2_ppmv', file_path)
    use_case = get_config_value(config, 'buildnml_input', 'use_case', file_path)
    lnd_tuning_mode = get_config_value(config, 'buildnml_input', 'lnd_tuning_mode', file_path)
    spinup = get_config_value(config, 'buildnml_input', 'spinup', file_path,
                              allowed_values=['off', 'on'])

    inputdata_path = get_config_value(config, 'buildnml_input', 'inputdata_path', file_path)

    # create config_cache.xml file
    # Note that build-namelist utilizes the contents of the config_cache.xml file in
    # the namelist_defaults.xml file to obtain namelist variables
    config_cache = os.path.join(rundir, "config_cache.xml")
    config_cache_text = _CONFIG_CACHE_TEMPLATE.format(clm_phys=ctsm_phys)
    with open(config_cache, 'w') as tempfile:
        tempfile.write(config_cache_text)

    # create temporary env_lilac.xml
    env_lilac = os.path.join(rundir, "env_lilac.xml")
    env_lilac_text = _ENV_LILAC_TEMPLATE.format()
    with open(env_lilac, 'w') as tempfile:
        tempfile.write(env_lilac_text)

    # remove any existing clm.input_data_list file
    inputdatalist_path = os.path.join(rundir, "clm.input_data_list")
    if os.path.exists(inputdatalist_path):
        os.remove(inputdatalist_path)

    # determine if fsurdat and/or finidat should appear in the -namelist option
    extra_namelist_opts = ''
    if fsurdat != _UNSET:
        extra_namelist_opts = extra_namelist_opts + " fsurdat = '{}' ".format(fsurdat)
    if finidat != _UNSET:
        extra_namelist_opts = extra_namelist_opts + " finidat = '{}' ".format(finidat)

    # call build-namelist
    cmd = os.path.abspath(os.path.join(bldnmldir, os.pardir, "bld", "build-namelist"))
    command = [cmd,
               '-csmdata', inputdata_path,
               '-inputdata', inputdatalist_path,
               # Hard-code start_ymd of year-2000. This is used to set the run type (for
               # which a setting of 2000 gives 'startup', which is what we want) and pick
               # the initial conditions file (which is pretty much irrelevant when running
               # with lilac).
               '-namelist', '&clm_inparm  start_ymd=20000101 {} /'.format(extra_namelist_opts),
               '-use_case', use_case,
               '-ignore_ic_year', # For now, we assume ignore_ic_year, not ignore_ic_date
               '-clm_start_type', 'default', # seems unimportant (see discussion in https://github.com/ESCOMP/CTSM/issues/876)
               '-configuration', configuration,
               '-structure', structure,
               '-lnd_frac', lnd_domain_file,
               '-glc_nec', str(10),
               '-co2_ppmv', co2_ppmv,
               '-co2_type', 'constant',
               '-clm_accelerated_spinup', spinup,
               '-lnd_tuning_mode', lnd_tuning_mode,
               '-no-megan',  # Eventually make this dynamic (see https://github.com/ESCOMP/CTSM/issues/926)
               '-config', os.path.join(rundir, "config_cache.xml"),
               '-envxml_dir', rundir]
    if use_existing_res_and_mask:
        command.extend(['-res', existing_res,
                        '-mask', existing_mask])
    else:
        # NOTE(wjs, 2020-06-16) Note that we do NOT use the -mask argument in this case;
        # it's possible that we should be using it in some circumstances (I haven't looked
        # into how it's used).
        command.extend(['-res', 'lilac',
                        '-clm_usr_name', 'lilac'])
    command.extend(bldnml_opts.split())

    subprocess.check_call(command,
                          universal_newlines=True)

    # remove temporary files in rundir
    os.remove(os.path.join(rundir, "config_cache.xml"))
    os.remove(os.path.join(rundir, "env_lilac.xml"))
    os.remove(os.path.join(rundir, "drv_flds_in"))

###############################################################################
def main():
    """Main function"""

    args = parse_command_line(sys.argv[1:], __doc__)
    bldnmldir = os.path.dirname(os.path.realpath(__file__))
    buildnml(
        rundir=args.rundir,
        bldnmldir=bldnmldir,
        use_existing_res_and_mask=args.use_existing_res_and_mask,
        existing_res=args.existing_res,
        existing_mask=args.existing_mask)


###############################################################################

if __name__ == "__main__":
    main()
