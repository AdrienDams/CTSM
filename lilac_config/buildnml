#!/usr/bin/env python

"""
CTSM namelist creator
"""

import sys, os, shutil, subprocess, logging, argparse
import six
from argparse import RawTextHelpFormatter

try:
    # python2
    from ConfigParser import SafeConfigParser as config_parser
    from ConfigParser import MissingSectionHeaderError
    from ConfigParser import NoSectionError, NoOptionError

    def config_string_cleaner(text):
        """convert strings into unicode
        """
        return text.decode('utf-8')
except ImportError:
    # python3
    from configparser import ConfigParser as config_parser
    from configparser import MissingSectionHeaderError
    from configparser import NoSectionError, NoOptionError

    def config_string_cleaner(text):
        """Python3 already uses unicode strings, so just return the string
        without modification.

        """
        return text

logger = logging.getLogger(__name__)

_config_cache_template = """
<?xml version="1.0"?>
<config_definition>
<commandline></commandline>
<entry id="phys" value="{clm_phys}" list="" valid_values="clm4_5,clm5_0">Specifies clm physics</entry>
</config_definition>
"""

# Note the following is needed in env_lilac.xml otherwise the following error appers in the call to build_namelist
#err=ERROR : CLM build-namelist::CLMBuildNamelist::logical_to_fortran() : Unexpected value in logical_to_fortran:

_env_lilac_template = """
<?xml version="1.0"?>
<file id="env_lilac.xml" version="2.0">
  <group id="run_glc">
    <entry id="GLC_TWO_WAY_COUPLING" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
    </entry>
  </group>
</file>
"""

_hack=object()

###############################################################################
def parse_command_line(args, description):
###############################################################################

    parser = argparse.ArgumentParser(formatter_class=RawTextHelpFormatter, description=description)

    parser.add_argument("--rundir", type=str, default=os.getcwd(),
                        help="(required) specify the full path of the run directory)")

    arguments = parser.parse_args(args)

    # check if rundir exists
    if not os.path.isdir(arguments.rundir):
        raise Exception("rundir %s does not exist".format(arguments.rundir))

    return arguments.rundir

###############################################################################
def run_cmd(cmd, input_str=None, from_dir=None, verbose=None,
            arg_stdout=_hack, arg_stderr=_hack, env=None, combine_output=False):
###############################################################################

    """
    Wrapper around subprocess to make it much more convenient to run shell commands

    >>> run_cmd('ls file_i_hope_doesnt_exist')[0] != 0
    True
    """
    import subprocess # Not safe to do globally, module not available in older pythons

    # Real defaults for these value should be subprocess.PIPE
    if arg_stdout is _hack:
        arg_stdout = subprocess.PIPE
    elif isinstance(arg_stdout, six.string_types):
        arg_stdout = _convert_to_fd(arg_stdout, from_dir)

    if arg_stderr is _hack:
        arg_stderr = subprocess.STDOUT if combine_output else subprocess.PIPE
    elif isinstance(arg_stderr, six.string_types):
        arg_stderr = _convert_to_fd(arg_stdout, from_dir)

    if (verbose != False and (verbose or logger.isEnabledFor(logging.DEBUG))):
        logger.info("RUN: {}\nFROM: {}".format(cmd, os.getcwd() if from_dir is None else from_dir))

    if (input_str is not None):
        stdin = subprocess.PIPE
    else:
        stdin = None

    proc = subprocess.Popen(cmd,
                            shell=True,
                            stdout=arg_stdout,
                            stderr=arg_stderr,
                            stdin=stdin,
                            cwd=from_dir,
                            env=env)

    output, errput = proc.communicate(input_str)
    if output is not None:
        try:
            output = output.decode('utf-8', errors='ignore').strip()
        except AttributeError:
            pass
    if errput is not None:
        try:
            errput = errput.decode('utf-8', errors='ignore').strip()
        except AttributeError:
            pass

    stat = proc.wait()
    if six.PY2:
        if isinstance(arg_stdout, file): # pylint: disable=undefined-variable
            arg_stdout.close() # pylint: disable=no-member
        if isinstance(arg_stderr, file) and arg_stderr is not arg_stdout: # pylint: disable=undefined-variable
            arg_stderr.close() # pylint: disable=no-member
    else:
        if isinstance(arg_stdout, io.IOBase):
            arg_stdout.close() # pylint: disable=no-member
        if isinstance(arg_stderr, io.IOBase) and arg_stderr is not arg_stdout:
            arg_stderr.close() # pylint: disable=no-member


    if (verbose != False and (verbose or logger.isEnabledFor(logging.DEBUG))):
        if stat != 0:
            logger.info("  stat: {:d}\n".format(stat))
        if output:
            logger.info("  output: {}\n".format(output))
        if errput:
            logger.info("  errput: {}\n".format(errput))

    return stat, output, errput

###############################################################################
def buildnml(rundir, bldnmldir):
###############################################################################

    """Build the ctsm namelist """

    file_path = os.path.join(rundir,'ctsm.cfg') 

    # read the config file
    config = config_parser()
    config.read(file_path) # TODO: add the code in externals_description.py to get the error checks

    clm_phys          = config.get('buildnml_input', 'clm_phys')
    start_type        = config.get('buildnml_input', 'start_type')
    start_ymd         = config.get('buildnml_input', 'start_ymd')
    startfile_type    = config.get('buildnml_input', 'startfile_type')
    ignore            = config.get('buildnml_input', 'ignore')
    configuration     = config.get('buildnml_input', 'configuration')
    structure         = config.get('buildnml_input', 'structure')
    ccsm_co2_ppmv     = config.get('buildnml_input', 'ccsm_co2_ppmv')
    clm_co2_type      = config.get('buildnml_input', 'clm_co2_type')
    clm_bldnml_opts   = config.get('buildnml_input', 'clm_bldnml_opts')
    use_case          = config.get('buildnml_input', 'use_case')
    lnd_tuning_mode   = config.get('buildnml_input', 'lnd_tuning_mode')
    spinup            = config.get('buildnml_input', 'spinup')
    gridmask          = config.get('buildnml_input', 'gridmask')
    lnd_grid          = config.get('buildnml_input', 'lnd_grid')
    lnd_domain_file   = config.get('buildnml_input', 'lnd_domain_file')
    lnd_domain_path   = config.get('buildnml_input', 'lnd_domain_path')
    din_loc_root      = config.get('buildnml_input', 'din_loc_root')
    clm_namelist_opts = config.get('buildnml_input', 'clm_namelist_opts')

    # create config_cache.xml file 
    # Note that build-namelist utilizes the contents of the config_cache.xml file in 
    # the namelist_defaults.xml file to obtain namelist variables
    config_cache   = os.path.join(rundir, "config_cache.xml")
    config_cache_text = _config_cache_template.format(clm_phys=clm_phys)
    with open(config_cache, 'w') as tempfile:
        tempfile.write(config_cache_text)

    # create temporary env_lilac.xml
    env_lilac = os.path.join(rundir, "env_lilac.xml")
    env_lilac_text = _env_lilac_template.format()
    with open(env_lilac, 'w') as tempfile:
        tempfile.write(env_lilac_text)

    # call build-namelist
    cmd = os.path.abspath(os.path.join(bldnmldir, os.pardir, "bld","build-namelist"))
    command = [cmd,
               '-csmdata', din_loc_root, 
               '-inputdata', os.path.join(rundir, "clm.input_data_list"), 
               '-namelist', '\'&clm_inparm  start_ymd={} {}/\''.format(start_ymd, clm_namelist_opts),
               '-use_case',use_case, 
               '-res', lnd_grid, 
               '-mask',gridmask,
               '-clm_start_type', start_type, 
               '-l_ncpl', str(1),  # this will not be used in lilac - but is needed as input
               '-configuration', configuration, 
               '-structure', structure,
               '-lnd_frac', os.path.join(lnd_domain_path,lnd_domain_file),
               '-glc_nec', str(10), 
               '-co2_ppmv', ccsm_co2_ppmv,
               '-co2_type', clm_co2_type, 
               '-clm_accelerated_spinup', spinup,
               '-lnd_tuning_mode',lnd_tuning_mode,
               '-config',os.path.join(rundir, "config_cache.xml"),
               '-envxml_dir', rundir, 
               clm_bldnml_opts]

    cmd = ' '.join(command)
    rc, out, err = run_cmd(cmd, from_dir=os.getcwd())
    if rc > 0:
        raise Exception("Command %s failed rc=%d\nout=%s\nerr=%s"%(cmd,rc,out,err))

    # remove temporary files in rundir
    os.remove(os.path.join(rundir, "config_cache.xml"))
    os.remove(os.path.join(rundir, "env_lilac.xml"))
    os.remove(os.path.join(rundir, "drv_flds_in"))

###############################################################################

if __name__ == "__main__":
    rundir = parse_command_line(sys.argv[1:], __doc__)
    bldnmldir = os.path.dirname(os.path.abspath(__file__))
    buildnml(rundir, bldnmldir)


